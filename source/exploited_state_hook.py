import angr
import claripy
from parse_helpers import hex2str
from util.info_print import fetch_str

class exploited_execve(angr.SimProcedure):
    """
    Sample hook procedure to check if the programme is going to do `execve("/bin/sh"...)`
    If the check pass, project.exploited_state will be set.
    """
    def run(self, filename, args, envp):
        # check if the first arg is like '/bin/sh'
        # fname = self.state.memory.load(filename, 9)
        fname = fetch_str(self.state, filename.args[0])
        # assert(fname.concrete)
        # if b"sh" in hex2str(fname.args[0]):
        if "sh" in fname:
            # print("""Found exploited state: execve("%s", ...)"""% fetch_str(self.state, filename.args[0]))
            print("""Found exploited state: execve("%s", ...)""" % fname)
            print("Replay finished.")

            # set exploited_state, so we can get the final state from project
            assert(self.project and self.state)
            self.project.exploited_state = self.state
            self.project.end_timestamp = len(self.state.history.bbl_addrs)
            # we don't need to continue
            self.exit(0)
        else:
            return claripy.BVV(0, 64)

    def __repr__(self):
        return '<exploited execve stub>'

def exploited_system(project):
    """
    Sample hook func to check if the programe is going to do `system("/bin/sh")`
    If the check pass, project.exploited_state will be set.

    :param:     replayer project, used to set exploited state
    """
    def hook_func(state):
        rdi = state.regs.rdi
        if rdi.concrete:
            command = state.memory.load(rdi, 8)
            if b"sh" in hex2str(command.args[0]):
                print("""Found exploited state: system(".*sh.*")""")
                project.exploited_state = state
        else:
            return
    return hook_func